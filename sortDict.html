<html>
<script>

// sorting dictionaries: returns a sorted list of key, value tuples
// we are given an object with properties, which store values
// we turn each property and its value into an array storing two values
/*function sortDict(dict) {
   var elemList = [];
   for (var property in dict) {
      if (dict.hasOwnProperty(property)) {
         // var property is now storing a string representation of what may or may not be a number
         var elem = [Number(property)||property, dict[property]];
         elemList.push(elem);
      }
   }
   elemList.sort(function(a,b) {
      // We sort by the VALUE (second #), from largest to smallest
      if (a[1] == b[1]) return 0;
      else if (a[1] > b[1]) return -1;
      else if (a[1] < b[1]) return 1;
   });
   return elemList;
}*/
console.log(sortDict({3:1,2:2,1:3}));

/*Test.assertSimilar(sortDict({1:3,2:2,3:1}),          [[1,3],[2,2],[3,1]]);*/
/*Test.assertSimilar(sortDict({1:2,2:4,3:6}),          [[3,6],[2,4],[1,2]]);*/


// BEST VERSION:
function sortDict(dict){
  return Object.keys(dict) // gives us an array of objects' enumerable properties. So basically the first thing we did above
    .map(function(v){ return [+v || v, dict[v]] }) // Turns it into 2d array with key/value. We do either Number(v) or v...so same thing as I did above
    .sort(function(a, b){ return a[1] < b[1] }) // Wouldnt this return 1/0 instead of 1/-1?
        // ANSWER: if the first is smaller than the second, it should go last (returns 1)
        // If the first is greater than the second, it will return 0. What would happen then?
        // If the function returns 0 (a is greater than b) it leaves the two UNCHANGED WITH RESPECT TO EACH OTHER
    ; 
}

</script>
</html>
